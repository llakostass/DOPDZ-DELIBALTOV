Второе дополнительное задание от Делибалтова Костаса из группы КВБО-01-21:

Условие задачи: В предыдущей версии предполагается, что для типа T определены оператор присваивания и конструктор по умолчанию. При создании шаблонных классов контейнеров (вроде Array и не только) разумно стараться минимизировать требования к типам шаблонных параметров. Поэтому усложним задачу, реализуйте класс Array не полагаясь на то, что для типа T определен оператор присваивания и конструктор по умолчанию. Конструктор копирования у типа T есть.

Hints: Hints: используйте placement new и явный вызов деструктора (смотрите урок 3.4), чтобы создавать и уничтожать объекты, аллоцировать правильно выровненную память можно с помощью new char[N * sizeof(T)], где N - количество элементов массива.

Решение:

#include <cstddef> 
template <typename T> 
class Array 
{
 public: 
 Array(size_t size, const T& value = T())  
    {
 size_ = size; 
 //Так как не существует конструктора по умолчанию, выделяем память через char(1 байт * Размер T) и приводим //к нужному нам типу 
 data_ = (T*) new char[size_ * sizeof(T)]; 
 //Потом проходим по массиву и явно вызываем конструктор с параметром 
 for (size_t i = 0; i != size_; ++i) 
 new (data_ + i) T(value); 
 //У типа T Есть конструктор с параметром и нет оператора присваивания 
 //Не можем написать data[i] = value; 
 //Память уже выделена выше, поэтому используем Placement new с конструктором с параметром 
    }
 Array()  
    {
 size_ = 0; 
 data_ = 0; 
    }
 Array(const Array & obj)  
    {
 size_ = obj.size(); 
 //Абсолютно такая же логика для конструктора копирования 
 data_ = (T*) new char[size_ * sizeof(T)]; 
 for (size_t i = 0; i != size_; ++i)  
 new (data_ + i) T(obj[i]); 
    }
 Array& operator=(const Array & obj) 
    {
 if (this != &obj)  
        {
 //Выкидываем то что было через наш недо деструктор 
 mem_free(); 
 //см конструктор 
 size_ = obj.size(); 
 data_ = (T*) new char[size_ * sizeof(T)]; 
 for (size_t i = 0; i != size_; ++i) 
 new (data_ + i) T(obj[i]); 
        }
 return *this; 
    }
 
 size_t size() const  
    {
 return size_; 
    }
 T& operator[](size_t i)  
    {
 return *(data_ + i); 
    }
 const T& operator[](size_t i) const  
    {
 return *(data_ + i); 
    }
 ~Array()  
    {
 //Не можем сделать delete [] data_ т. к выделяли память через бубен 
 mem_free(); 
    }
 
 void mem_free() 
    {
 for (size_t i = 0; i != size_; ++i)  
 data_[i].~T(); // Явно вызываем деструктор у каждого элемента 
 delete [] (char *) data_; // Выделяли память через [] char? Удаляем через [] char! 
    }
 
    private :
        size_t size_ ;
        T * data_ ;
};